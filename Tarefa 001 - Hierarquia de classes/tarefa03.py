# -*- coding: utf-8 -*-
"""Tarefa03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1j5db6XFBVOyBHzl5k_zyvcij1xRMgFDU

# Hierarquia de Estruturas de Dados Lineares
#
#### Douglas Nery, Felipe Cockless, Rumenick Brandi
"""



#Hierarquia de Estruturas de Dados Lineares
class HEDL:
    def __init__(self,Capacity):
        self.capacity = Capacity

    def __len__(self):
        return self.capacity

    def __getitem__(self, index):
        return self.data[index]

    def __setitem__(self, index, value):
        self.data[index] = value

    def is_empty(self):
        return len(self.data) == 0

    def is_full(self):
        return len(self.data) == self.capacity

    def append(self,data):
        if len(self.data) >= self.capacity:
            raise FullStackError("A estrutura está cheia")
        self.data.append(item)

    def pop(self,index=None):
        if self.is_empty():
            raise EmptyStackError("A estrutura está vazia")
        if index != None:
            intermediary = []
            for i,item in enumerate(self.data):
                if i != index:
                    intermediary.append(item)
                else:
                    excluded_item = item
            self.data = intermediary
            return excluded_item
        else:
            return self.data.pop()

    #def appbegin(self,data):
        #if len(self.data) >= self.capacity:
        #    raise FullStackError("A pilha está cheia")
        #intermediary_pass = [data]


class FullStackError(Exception):
    pass

class EmptyStackError(Exception):
    pass

"""# Array"""

class array(HEDL):
    def __init__(self,array):
        self.data = array
        super().__init__(len(array))

    def __str__(self):
        sttr = "array("
        lisst = []
        for item in self.data:
            lisst.append(item)
        sttr = sttr+f"{lisst})"
        return sttr

    def __mul__(self,other):
        if type(other) == int or type(other) == float:
            return self.__rmul__(other)
        if len(self.data) != len(other):
            raise ValueError("Arrays must have the same length.")
        result = array([item*other[i] for i,item in enumerate(self.data)])
        print(result)

    def __rmul__(self,scalar):
        result = array([x*scalar for x in self.data])
        print(result)

    def __ge__(self,other):
        if len(self.data) != len(other):
            raise ValueError("Arrays must have the same length.")
        result = []
        for index,item in enumerate(self.data):
            if item >= other[index]:
                result.append(True)
            else:
                result.append(False)
        result = array(result)
        print(result)

    def __pow__(self,number):
        result = array([item**number for item in self.data])
        print(result)

#Test area
#a = array([1,2,3,4])
#b = array([5,6,2,1])
#a[0] = 10
#a>=b
#print(len(a),len(b))
#a*5
#a*b
#a**2
#print(a,b)
#10 == a[0]



"""# Lista Encadeada Simples"""

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList(HEDL):
    def __init__(self):
        self.head = None

    def append(self, data):
        new_node = Node(data)
        if not self.head:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def __repr__(self):
        current = self.head
        while current:
            print(f"{current.data}", end=" -> ")
            current = current.next
        #print("None")
